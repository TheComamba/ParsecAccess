// This code is generated by generate_code.py, do not modify it manually.

//! Provides access to the data files for the PARSEC stellar evolution models.

use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use std::ops::Index;

use crate::{error::ParsecAccessError, trajectory::Trajectory};

use super::metallicity::Metallicity;

lazy_static! {
    static ref Z0_0001_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0002_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0005_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0010_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0020_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0040_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0060_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0080_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0100_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0140_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0170_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0200_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0300_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0400_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
    static ref Z0_0600_DATA: Result<ParsecData, ParsecAccessError> = ParsecData::new();
}

lazy_static! {
    static ref DATA: [&'static Result<ParsecData, ParsecAccessError>; 15] = [
        &Z0_0001_DATA,
        &Z0_0002_DATA,
        &Z0_0005_DATA,
        &Z0_0010_DATA,
        &Z0_0020_DATA,
        &Z0_0040_DATA,
        &Z0_0060_DATA,
        &Z0_0080_DATA,
        &Z0_0100_DATA,
        &Z0_0140_DATA,
        &Z0_0170_DATA,
        &Z0_0200_DATA,
        &Z0_0300_DATA,
        &Z0_0400_DATA,
        &Z0_0600_DATA,
    ];
}

#[derive(Deserialize, Serialize)]
pub(crate) struct ParsecData {
    pub metallicity: Metallicity,
    pub(crate) data: Vec<Trajectory>,
}

impl Index<usize> for ParsecData {
    type Output = Trajectory;

    fn index(&self, index: usize) -> &Self::Output {
        &self.data[index]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[ignore]
    fn data_access_is_fast() {
        const N: usize = 1e6 as usize;
        const PRIME1: usize = 1009;
        const PRIME2: usize = 1013;
        const PRIME3: usize = 10007;
        const MAX_METALLICITY_INDEX: usize = 10;
        const MAX_MASS_INDEX: usize = 50;
        const MAX_TRAJECTORY_INDEX: usize = 100;

        // Ensure that the data is loaded into memory.
        let _ = DATA[1].as_ref().unwrap()[1][1];

        // Create pseudo-random indices.
        let mut indices = Vec::new();
        for i in 0..N {
            let metallicity_index = (i * PRIME1) % MAX_METALLICITY_INDEX;
            let mass_index = (i * PRIME2) % MAX_MASS_INDEX;
            let trajectory_index = (i * PRIME3) % MAX_TRAJECTORY_INDEX;
            indices.push((metallicity_index, mass_index, trajectory_index));
        }

        // Access the data in a pseudo-random order.
        let now = std::time::Instant::now();
        let mut total_mass = 0.;
        for (metallicity_index, mass_index, trajectory_index) in indices {
            let m = DATA[metallicity_index].as_ref().unwrap()[mass_index][trajectory_index]
                .mass_in_solar_masses;
            total_mass += m;
        }
        let elapsed = now.elapsed();
        println!("Collected a total mass of {} solar masses.", total_mass);

        println!("Accessing {} data points took {:?}", N, elapsed);
    }
}
